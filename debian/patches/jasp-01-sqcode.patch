Index: zbar-0.10+doc/configure.ac
===================================================================
--- zbar-0.10+doc.orig/configure.ac
+++ zbar-0.10+doc/configure.ac
@@ -79,9 +79,9 @@ dnl symbologies
 
 AC_ARG_ENABLE([codes],
   [AS_HELP_STRING([--enable-codes=SYMS],
-    [select symbologies to compile [default=ean,i25,code39,code128,qrcode]])],
+    [select symbologies to compile [default=ean,i25,code39,code128,qrcode,sqcode]])],
   [],
-  [enable_codes="ean,code39,code128,i25,qrcode"]) dnl pdf417
+  [enable_codes="ean,code39,code128,i25,qrcode,sqcode"]) dnl pdf417
 
 AC_DEFUN([ZBAR_CHK_CODE], [
   AC_MSG_CHECKING([whether to build $2])
@@ -104,6 +104,7 @@ ZBAR_CHK_CODE([code39], [Code 39 symbolo
 ZBAR_CHK_CODE([pdf417], [PDF417 symbology])
 ZBAR_CHK_CODE([i25], [Interleaved 2 of 5 symbology])
 ZBAR_CHK_CODE([qrcode], [QR Code])
+ZBAR_CHK_CODE([sqcode], [SQ Code])
 
 dnl libraries
 
Index: zbar-0.10+doc/include/zbar.h
===================================================================
--- zbar-0.10+doc.orig/include/zbar.h
+++ zbar-0.10+doc/include/zbar.h
@@ -96,6 +96,7 @@ typedef enum zbar_symbol_type_e {
     ZBAR_CODE39      =     39,  /**< Code 39. @since 0.4 */
     ZBAR_PDF417      =     57,  /**< PDF417. @since 0.6 */
     ZBAR_QRCODE      =     64,  /**< QR Code. @since 0.10 */
+    ZBAR_SQCODE      =     96,  /**< SQ Code. @since 0.10 */
     ZBAR_CODE128     =    128,  /**< Code 128 */
     ZBAR_SYMBOL      = 0x00ff,  /**< mask for base symbol type */
     ZBAR_ADDON2      = 0x0200,  /**< 2-digit add-on flag */
Index: zbar-0.10+doc/python/zbarmodule.c
===================================================================
--- zbar-0.10+doc.orig/python/zbarmodule.c
+++ zbar-0.10+doc/python/zbarmodule.c
@@ -194,5 +194,6 @@ initzbar (void)
     zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_CODE39,  "CODE39");
     zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_PDF417,  "PDF417");
     zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_QRCODE,  "QRCODE");
+    zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_SQCODE,  "SQCODE");
     zbarEnumItem_New(tp_dict, symbol_enum, ZBAR_CODE128, "CODE128");
 }
Index: zbar-0.10+doc/zbar/Makefile.am.inc
===================================================================
--- zbar-0.10+doc.orig/zbar/Makefile.am.inc
+++ zbar-0.10+doc/zbar/Makefile.am.inc
@@ -42,6 +42,10 @@ zbar_libzbar_la_SOURCES += zbar/qrcode.h
     zbar/qrcode/binarize.h zbar/qrcode/binarize.c \
     zbar/qrcode/util.h zbar/qrcode/util.c
 endif
+if ENABLE_SQCODE
+zbar_libzbar_la_SOURCES += zbar/sqcode.h zbar/sqcode.c \
+    zbar/decoder/sq_finder.h zbar/decoder/sq_finder.c
+endif
 
 if WIN32
 zbar_libzbar_la_SOURCES += zbar/processor/win.c zbar/libzbar.rc
Index: zbar-0.10+doc/zbar/config.c
===================================================================
--- zbar-0.10+doc.orig/zbar/config.c
+++ zbar-0.10+doc/zbar/config.c
@@ -46,6 +46,8 @@ int zbar_parse_config (const char *cfgst
             return(1);
         else if(!strncmp(cfgstr, "qrcode", len))
             *sym = ZBAR_QRCODE;
+        else if(!strncmp(cfgstr, "sqcode", len))
+            *sym = ZBAR_SQCODE;
         else if(len < 3)
             return(1);
         else if(!strncmp(cfgstr, "upca", len))
Index: zbar-0.10+doc/zbar/decoder.c
===================================================================
--- zbar-0.10+doc.orig/zbar/decoder.c
+++ zbar-0.10+doc/zbar/decoder.c
@@ -32,6 +32,7 @@
 #if defined(DEBUG_DECODER) || defined(DEBUG_EAN) ||             \
     defined(DEBUG_CODE39) || defined(DEBUG_I25) ||              \
     defined(DEBUG_CODE128) || defined(DEBUG_QR_FINDER) ||       \
+    defined(DEBUG_SQ_FINDER) ||                                 \
     (defined(DEBUG_PDF417) && (DEBUG_PDF417 >= 4))
 # define DEBUG_LEVEL 1
 #endif
@@ -72,6 +73,9 @@ zbar_decoder_t *zbar_decoder_create ()
 #ifdef ENABLE_QRCODE
     dcode->qrf.config = 1 << ZBAR_CFG_ENABLE;
 #endif
+#ifdef ENABLE_SQCODE
+    dcode->sqf.config = 1 << ZBAR_CFG_ENABLE;
+#endif
 
     zbar_decoder_reset(dcode);
     return(dcode);
@@ -287,6 +291,12 @@ static inline int decoder_set_config_boo
         break;
 #endif
 
+#ifdef ENABLE_SQCODE
+    case ZBAR_SQCODE:
+        config = &dcode->sqf.config;
+        break;
+#endif
+
     /* FIXME handle addons */
 
     default:
@@ -366,6 +376,7 @@ int zbar_decoder_set_config (zbar_decode
         zbar_decoder_set_config(dcode, ZBAR_CODE128, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_PDF417, cfg, val);
         zbar_decoder_set_config(dcode, ZBAR_QRCODE, cfg, val);
+        zbar_decoder_set_config(dcode, ZBAR_SQCODE, cfg, val);
         return(0);
     }
 
Index: zbar-0.10+doc/zbar/decoder.h
===================================================================
--- zbar-0.10+doc.orig/zbar/decoder.h
+++ zbar-0.10+doc/zbar/decoder.h
@@ -48,6 +48,9 @@
 #ifdef ENABLE_QRCODE
 # include "decoder/qr_finder.h"
 #endif
+#ifdef ENABLE_SQCODE
+# include "decoder/sq_finder.h"
+#endif
 
 /* size of bar width history (implementation assumes power of two) */
 #ifndef DECODE_WINDOW
@@ -107,6 +110,9 @@ struct zbar_decoder_s {
 #ifdef ENABLE_QRCODE
     qr_finder_t qrf;                    /* QR Code finder state */
 #endif
+#ifdef ENABLE_SQCODE
+    sq_finder_t sqf;                    /* SQ Code finder state */
+#endif
 };
 
 /* return current element color */
Index: zbar-0.10+doc/zbar/decoder/sq_finder.c
===================================================================
--- /dev/null
+++ zbar-0.10+doc/zbar/decoder/sq_finder.c
@@ -0,0 +1,7 @@
+#include "sq_finder.h"
+#include "decoder.h"
+
+unsigned _zbar_decoder_get_sq_finder_config(zbar_decoder_t *dcode)
+{
+    return dcode->sqf.config;
+}
Index: zbar-0.10+doc/zbar/decoder/sq_finder.h
===================================================================
--- /dev/null
+++ zbar-0.10+doc/zbar/decoder/sq_finder.h
@@ -0,0 +1,9 @@
+#ifndef _DECODER_SQ_FINDER_H_
+#define _DECODER_SQ_FINDER_H_
+
+/* SQ Code symbol finder state */
+typedef struct sq_finder_s {
+    unsigned config;
+} sq_finder_t;
+
+#endif
Index: zbar-0.10+doc/zbar/img_scanner.c
===================================================================
--- zbar-0.10+doc.orig/zbar/img_scanner.c
+++ zbar-0.10+doc/zbar/img_scanner.c
@@ -38,6 +38,9 @@
 #ifdef ENABLE_QRCODE
 # include "qrcode.h"
 #endif
+#ifdef ENABLE_SQCODE
+# include "sqcode.h"
+#endif
 #include "img_scanner.h"
 #include "svg.h"
 
@@ -94,6 +97,9 @@ struct zbar_image_scanner_s {
 #ifdef ENABLE_QRCODE
     qr_reader *qr;              /* QR Code 2D reader */
 #endif
+#ifdef ENABLE_SQCODE
+    sq_reader *sq;              /* SQ Code 2D reader */
+#endif
 
     const void *userdata;       /* application data */
     /* user result callback */
@@ -385,6 +391,16 @@ static inline void qr_handler (zbar_imag
 }
 #endif
 
+#ifdef ENABLE_SQCODE
+extern unsigned _zbar_decoder_get_sq_finder_config(zbar_decoder_t*);
+
+static void sq_handler (zbar_image_scanner_t *iscn)
+{
+    unsigned config = _zbar_decoder_get_sq_finder_config(iscn->dcode);
+    _zbar_sq_new_config(iscn->sq, config);
+}
+#endif
+
 static void symbol_handler (zbar_decoder_t *dcode)
 {
     zbar_image_scanner_t *iscn = zbar_decoder_get_userdata(dcode);
@@ -464,6 +480,10 @@ zbar_image_scanner_t *zbar_image_scanner
     iscn->qr = _zbar_qr_create();
 #endif
 
+#ifdef ENABLE_SQCODE
+    iscn->sq = _zbar_sq_create();
+#endif
+
     /* apply default configuration */
     CFG(iscn, ZBAR_CFG_X_DENSITY) = 1;
     CFG(iscn, ZBAR_CFG_Y_DENSITY) = 1;
@@ -517,6 +537,12 @@ void zbar_image_scanner_destroy (zbar_im
         iscn->qr = NULL;
     }
 #endif
+#ifdef ENABLE_SQCODE
+    if(iscn->sq) {
+        _zbar_sq_destroy(iscn->sq);
+        iscn->sq = NULL;
+    }
+#endif
     free(iscn);
 }
 
@@ -614,6 +640,10 @@ int zbar_scan_image (zbar_image_scanner_
     _zbar_qr_reset(iscn->qr);
 #endif
 
+#ifdef ENABLE_SQCODE
+    _zbar_sq_reset(iscn->sq);
+#endif
+
     /* get grayscale image, convert if necessary */
     if(img->format != fourcc('Y','8','0','0') &&
        img->format != fourcc('G','R','E','Y'))
@@ -752,6 +782,11 @@ int zbar_scan_image (zbar_image_scanner_
     _zbar_qr_decode(iscn->qr, iscn, img);
 #endif
 
+#ifdef ENABLE_SQCODE
+    sq_handler(iscn);
+    _zbar_sq_decode(iscn->sq, iscn, img);
+#endif
+
     /* FIXME tmp hack to filter bad EAN results */
     if(syms->nsyms && !iscn->enable_cache &&
        (density == 1 || CFG(iscn, ZBAR_CFG_Y_DENSITY) == 1)) {
Index: zbar-0.10+doc/zbar/sqcode.c
===================================================================
--- /dev/null
+++ zbar-0.10+doc/zbar/sqcode.c
@@ -0,0 +1,548 @@
+/*Copyright (C) 2018 Javier Serrano Polo <javier@jasp.net>
+  You can redistribute this library and/or modify it under the terms of the
+   GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2.1 of the License, or (at your option) any later
+   version.*/
+#include "sqcode.h"
+
+#include <stdbool.h>
+#include <stdlib.h>
+
+#include "image.h"
+#include "img_scanner.h"
+
+typedef enum {
+    SHAPE_DOT,
+    SHAPE_CORNER,
+    SHAPE_OTHER,
+    SHAPE_VOID
+} shape_t;
+
+typedef struct {
+    float x;
+    float y;
+} sq_point;
+
+typedef struct {
+    shape_t type;
+    unsigned x0;
+    unsigned y0;
+    unsigned width;
+    unsigned height;
+    sq_point center;
+} sq_dot;
+
+struct sq_reader {
+    bool enabled;
+};
+
+/*Initializes a client reader handle.*/
+static void sq_reader_init(sq_reader *reader)
+{
+    reader->enabled = true;
+}
+
+/*Allocates a client reader handle.*/
+sq_reader *_zbar_sq_create(void)
+{
+    sq_reader *reader = malloc(sizeof(sq_reader));
+    if (reader)
+        sq_reader_init(reader);
+    return reader;
+}
+
+/*Frees a client reader handle.*/
+void _zbar_sq_destroy(sq_reader *reader)
+{
+    free(reader);
+}
+
+/* reset finder state between scans */
+void _zbar_sq_reset (sq_reader *reader)
+{
+    reader->enabled = true;
+}
+
+int _zbar_sq_new_config(sq_reader *reader,
+                        unsigned config)
+{
+    reader->enabled = config;
+    return 0;
+}
+
+static const char base64_table[] = {
+	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
+	'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b',
+	'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
+	'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3',
+	'4', '5', '6', '7', '8', '9', '+', '/'
+};
+
+static char *base64_encode_buffer(const char *s, size_t size) {
+	size_t encoded_size = (size + 2) / 3 * 4 + 1;
+	char *encoded = malloc(encoded_size);
+	if (!encoded)
+		return NULL;
+	char *e = encoded;
+	for (;;) {
+		unsigned char c = (*s >> 2) & 0x3f;
+		*e++ = base64_table[c];
+		c = (*s++ << 4) & 0x30;
+		if (!--size) {
+			*e++ = base64_table[c];
+			*e++ = '=';
+			*e++ = '=';
+			break;
+		}
+		c |= (*s >> 4) & 0x0f;
+		*e++ = base64_table[c];
+		c = (*s++ << 2) & 0x3c;
+		if (!--size) {
+			*e++ = base64_table[c];
+			*e++ = '=';
+			break;
+		}
+		c |= (*s >> 6) & 0x03;
+		*e++ = base64_table[c];
+		c = *s++ & 0x3f;
+		*e++ = base64_table[c];
+		if (!--size)
+			break;
+	}
+	*e = '\0';
+	return encoded;
+}
+
+static bool sq_extract_text(zbar_image_scanner_t *iscn,
+                            const char *buf,
+                            size_t len)
+{
+    zbar_symbol_t *sym = _zbar_image_scanner_alloc_sym(iscn, ZBAR_SQCODE, 0);
+    sym->data = base64_encode_buffer(buf, len);
+    if (!sym->data) {
+        _zbar_image_scanner_recycle_syms(iscn, sym);
+        return true;
+    }
+    size_t b64_len = (len + 2) / 3 * 4;
+    sym->data_alloc = b64_len + 1;
+    sym->datalen = b64_len;
+    _zbar_image_scanner_add_sym(iscn, sym);
+    return false;
+}
+
+static bool is_black_color(const unsigned char c)
+{
+    return c <= 0x7f;
+}
+
+static bool is_black(zbar_image_t *img, int x, int y)
+{
+    if (x < 0 || x >= img->width || y < 0 || y >= img->height)
+        return false;
+    const unsigned char *data = img->data;
+    return is_black_color(data[y * img->width + x]);
+}
+
+static void set_dot_center(sq_dot *dot, float x, float y)
+{
+    dot->center.x = x;
+    dot->center.y = y;
+}
+
+static void sq_scan_shape(zbar_image_t *img, sq_dot *dot, int start_x,
+    int start_y)
+{
+    if (!is_black(img, start_x, start_y)) {
+        dot->type = SHAPE_VOID;
+        dot->x0 = start_x;
+        dot->y0 = start_y;
+        dot->width = 0;
+        dot->height = 0;
+        set_dot_center(dot, start_x, start_y);
+        return;
+    }
+
+    unsigned x0 = start_x;
+    unsigned y0 = start_y;
+    unsigned width = 1;
+    unsigned height = 1;
+
+new_point:
+    for (int x = x0 - 1; x < x0 + width + 1; x++) {
+        if (is_black(img, x, y0 - 1)) {
+            y0 = y0 - 1;
+            height++;
+            goto new_point;
+        }
+        if (is_black(img, x, y0 + height)) {
+            height++;
+            goto new_point;
+        }
+    }
+    for (int y = y0; y < y0 + height; y++) {
+        if (is_black(img, x0 - 1, y)) {
+            x0 = x0 - 1;
+            width++;
+            goto new_point;
+        }
+        if (is_black(img, x0 + width, y)) {
+            width++;
+            goto new_point;
+        }
+    }
+
+    dot->x0 = x0;
+    dot->y0 = y0;
+    dot->width = width;
+    dot->height = height;
+
+    /* TODO: Is it other shape? White hole? */
+
+    /* Is it a corner? */
+    if (is_black(img, x0 + 0.25 * width, y0 + 0.25 * height)
+        && !is_black(img, x0 + 0.75 * width, y0 + 0.25 * height)
+        && !is_black(img, x0 + 0.25 * width, y0 + 0.75 * height)
+        && is_black(img, x0 + 0.75 * width, y0 + 0.75 * height)) {
+        dot->type = SHAPE_CORNER;
+        set_dot_center(dot, x0 + 0.5 * width, y0 + 0.5 * height);
+        return;
+    }
+
+    /* Set dot center */
+    const unsigned char *data = img->data;
+    unsigned x_sum = 0;
+    unsigned y_sum = 0;
+    unsigned total_weight = 0;
+    for (int y = y0; y < y0 + height; y++) {
+        for (int x = x0; x < x0 + width; x++) {
+            if (!is_black(img, x, y))
+                continue;
+            unsigned char weight = 0xff - data[y * img->width + x];
+            x_sum += weight * x;
+            y_sum += weight * y;
+            total_weight += weight;
+        }
+    }
+    dot->type = SHAPE_DOT;
+    set_dot_center(dot, x_sum / (float) total_weight + 0.5,
+        y_sum / (float) total_weight + 0.5);
+}
+
+static void set_middle_point(sq_point *middle, const sq_point *start,
+    const sq_point *end)
+{
+    middle->x = (start->x + end->x) / 2;
+    middle->y = (start->y + end->y) / 2;
+}
+
+bool find_left_dot(zbar_image_t *img, sq_dot *dot, unsigned *found_x,
+    unsigned *found_y)
+{
+    for (int y = dot->y0; y < dot->y0 + dot->height; y++) {
+        /* x >= (int) (dot->x0 - 2 * dot->width) */
+        for (int x = dot->x0 - 1; x + 2 * dot->width >= dot->x0; x--) {
+            if (is_black(img, x, y)) {
+                *found_x = x;
+                *found_y = y;
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool find_right_dot(zbar_image_t *img, sq_dot *dot, unsigned *found_x,
+    unsigned *found_y)
+{
+    for (int y = dot->y0; y < dot->y0 + dot->height; y++) {
+        for (int x = dot->x0 + dot->width; x < dot->x0 + 3 * dot->width; x++) {
+            if (is_black(img, x, y)) {
+                *found_x = x;
+                *found_y = y;
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool find_bottom_dot(zbar_image_t *img, sq_dot *dot, unsigned *found_x,
+    unsigned *found_y)
+{
+    for (int x = dot->x0 + dot->width - 1; x >= dot->x0; x--) {
+        for (int y = dot->y0 + dot->height; y < dot->y0 + 3 * dot->height;
+            y++) {
+            if (is_black(img, x, y)) {
+                *found_x = x;
+                *found_y = y;
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+int _zbar_sq_decode (sq_reader *reader,
+                     zbar_image_scanner_t *iscn,
+                     zbar_image_t *img)
+{
+    if (!reader->enabled)
+        return 0;
+
+    if (img->format != fourcc('Y','8','0','0')) {
+        fputs("Unexpected image format\n", stderr);
+        return 1;
+    }
+
+    /* Starting pixel */
+    unsigned scan_y;
+    unsigned scan_x;
+    for (scan_y = 0; scan_y < img->height; scan_y++) {
+        for (scan_x = 0; scan_x < img->width; scan_x++) {
+            if (is_black(img, scan_x, scan_y))
+                goto found_start;
+        }
+    }
+    return 1;
+
+found_start: ;
+    /* Starting dot */
+    sq_dot start_dot;
+    sq_scan_shape(img, &start_dot, scan_x, scan_y);
+
+    bool start_corner = start_dot.type == SHAPE_CORNER;
+
+    bool error = true;
+
+    sq_point *top_border = NULL;
+    sq_point *left_border = NULL;
+    sq_point *right_border = NULL;
+    sq_point *bottom_border = NULL;
+
+    size_t border_len;
+    if (start_corner) {
+        border_len = 0;
+    }
+    else {
+        border_len = 1;
+        top_border = malloc(sizeof(sq_point));
+        if (!top_border)
+            return 1;
+        top_border[0] = start_dot.center;
+    }
+
+    sq_dot top_left_dot = start_dot;
+    while (find_left_dot(img, &top_left_dot, &scan_x, &scan_y)) {
+        sq_scan_shape(img, &top_left_dot, scan_x, scan_y);
+        if (top_left_dot.type != SHAPE_DOT)
+            goto free_borders;
+        if (border_len) {
+            border_len += 2;
+            void *ptr = realloc(top_border, border_len * sizeof(sq_point));
+            if (!ptr)
+                goto free_borders;
+            top_border = ptr;
+            for (size_t i = border_len - 1; i >= 2; i--)
+                top_border[i] = top_border[i - 2];
+            top_border[0] = top_left_dot.center;
+            set_middle_point(&top_border[1], &top_border[0], &top_border[2]);
+        }
+        else {
+            border_len = 1;
+            top_border = malloc(sizeof(sq_point));
+            if (!top_border)
+                return 1;
+            top_border[0] = top_left_dot.center;
+        }
+    }
+    if (top_left_dot.type != SHAPE_DOT)
+        goto free_borders;
+
+    sq_dot top_right_dot = start_dot;
+    if (!start_corner) {
+        while (find_right_dot(img, &top_right_dot, &scan_x, &scan_y)) {
+            sq_scan_shape(img, &top_right_dot, scan_x, scan_y);
+            if (top_right_dot.type == SHAPE_CORNER)
+                break;
+            if (top_right_dot.type != SHAPE_DOT)
+                goto free_borders;
+            border_len += 2;
+            void *ptr = realloc(top_border, border_len * sizeof(sq_point));
+            if (!ptr)
+                goto free_borders;
+            top_border = ptr;
+            top_border[border_len - 1] = top_right_dot.center;
+            set_middle_point(&top_border[border_len - 2],
+                &top_border[border_len - 3],
+                &top_border[border_len - 1]);
+        }
+    }
+    if (border_len < 3)
+        goto free_borders;
+    float inc_x = top_border[border_len - 1].x - top_border[border_len - 3].x;
+    float inc_y = top_border[border_len - 1].y - top_border[border_len - 3].y;
+    border_len += 3;
+    void *ptr = realloc(top_border, border_len * sizeof(sq_point));
+    if (!ptr)
+        goto free_borders;
+    top_border = ptr;
+    top_border[border_len - 3].x = top_border[border_len - 4].x + 0.5 * inc_x;
+    top_border[border_len - 3].y = top_border[border_len - 4].y + 0.5 * inc_y;
+    top_border[border_len - 2].x = top_border[border_len - 4].x + inc_x;
+    top_border[border_len - 2].y = top_border[border_len - 4].y + inc_y;
+    top_border[border_len - 1].x = top_border[border_len - 4].x + 1.5 * inc_x;
+    top_border[border_len - 1].y = top_border[border_len - 4].y + 1.5 * inc_y;
+
+    left_border = malloc(border_len * sizeof(sq_point));
+    if (!left_border)
+        goto free_borders;
+    left_border[0] = top_border[0];
+
+    sq_dot bottom_left_dot = top_left_dot;
+    size_t cur_len = 1;
+    while (find_bottom_dot(img, &bottom_left_dot, &scan_x, &scan_y)) {
+        sq_scan_shape(img, &bottom_left_dot, scan_x, scan_y);
+        if (bottom_left_dot.type == SHAPE_CORNER)
+            break;
+        if (bottom_left_dot.type != SHAPE_DOT)
+            goto free_borders;
+        cur_len += 2;
+        left_border[cur_len - 1] = bottom_left_dot.center;
+        set_middle_point(&left_border[cur_len - 2],
+            &left_border[cur_len - 3],
+            &left_border[cur_len - 1]);
+    }
+    if (cur_len != border_len - 3 || bottom_left_dot.type != SHAPE_CORNER)
+        goto free_borders;
+    inc_x = left_border[cur_len - 1].x - left_border[cur_len - 3].x;
+    inc_y = left_border[cur_len - 1].y - left_border[cur_len - 3].y;
+    left_border[border_len - 3].x = left_border[border_len - 4].x + 0.5 * inc_x;
+    left_border[border_len - 3].y = left_border[border_len - 4].y + 0.5 * inc_y;
+    left_border[border_len - 2].x = left_border[border_len - 4].x + inc_x;
+    left_border[border_len - 2].y = left_border[border_len - 4].y + inc_y;
+    left_border[border_len - 1].x = left_border[border_len - 4].x + 1.5 * inc_x;
+    left_border[border_len - 1].y = left_border[border_len - 4].y + 1.5 * inc_y;
+
+    right_border = malloc(border_len * sizeof(sq_point));
+    if (!right_border)
+        goto free_borders;
+
+    sq_dot bottom_right_dot = top_right_dot;
+    cur_len = 3;
+    while (find_bottom_dot(img, &bottom_right_dot, &scan_x, &scan_y)) {
+        sq_scan_shape(img, &bottom_right_dot, scan_x, scan_y);
+        if (bottom_right_dot.type != SHAPE_DOT)
+            goto free_borders;
+        if (cur_len == 3) {
+            cur_len++;
+            right_border[cur_len - 1] = bottom_right_dot.center;
+        }
+        else {
+            cur_len += 2;
+            right_border[cur_len - 1] = bottom_right_dot.center;
+            set_middle_point(&right_border[cur_len - 2],
+                &right_border[cur_len - 3],
+                &right_border[cur_len - 1]);
+        }
+    }
+    if (cur_len != border_len || border_len < 6)
+        return 1;
+    inc_x = right_border[5].x - right_border[3].x;
+    inc_y = right_border[5].y - right_border[3].y;
+    right_border[2].x = right_border[3].x - 0.5 * inc_x;
+    right_border[2].y = right_border[3].y - 0.5 * inc_y;
+    right_border[1].x = right_border[3].x - inc_x;
+    right_border[1].y = right_border[3].y - inc_y;
+    right_border[0].x = right_border[3].x - 1.5 * inc_x;
+    right_border[0].y = right_border[3].y - 1.5 * inc_y;
+
+    bottom_border = malloc(border_len * sizeof(sq_point));
+    if (!bottom_border)
+        goto free_borders;
+    bottom_border[border_len - 1] = right_border[border_len - 1];
+
+    sq_dot bottom_left2_dot = bottom_right_dot;
+    size_t offset = border_len - 1;
+    while (find_left_dot(img, &bottom_left2_dot, &scan_x, &scan_y)) {
+        sq_scan_shape(img, &bottom_left2_dot, scan_x, scan_y);
+        if (bottom_left2_dot.type == SHAPE_CORNER)
+            break;
+        if (bottom_left2_dot.type != SHAPE_DOT)
+            goto free_borders;
+        offset -= 2;
+        bottom_border[offset] = bottom_left2_dot.center;
+        set_middle_point(&bottom_border[offset + 1],
+            &bottom_border[offset],
+            &bottom_border[offset + 2]);
+    }
+    if (offset != 3 || bottom_left2_dot.type != SHAPE_CORNER)
+        goto free_borders;
+    inc_x = bottom_border[5].x - bottom_border[3].x;
+    inc_y = bottom_border[5].y - bottom_border[3].y;
+    bottom_border[2].x = bottom_border[3].x - 0.5 * inc_x;
+    bottom_border[2].y = bottom_border[3].y - 0.5 * inc_y;
+    bottom_border[1].x = bottom_border[3].x - inc_x;
+    bottom_border[1].y = bottom_border[3].y - inc_y;
+    bottom_border[0].x = bottom_border[3].x - 1.5 * inc_x;
+    bottom_border[0].y = bottom_border[3].y - 1.5 * inc_y;
+
+    /* Size check */
+    if (border_len < 8 + 2 * (1 + 2) || border_len > 65535)
+        goto free_borders;
+    size_t bit_side_len = border_len - 2 * (1 + 2);
+
+    size_t bit_len = bit_side_len * bit_side_len;
+    if (bit_len % 8)
+        goto free_borders;
+    size_t byte_len = bit_len / 8;
+    char *buf = calloc(byte_len, sizeof(char));
+    if (!buf)
+        goto free_borders;
+
+    size_t idx = 0;
+    for (unsigned y = 3; y <= border_len - 4; y++) {
+        for (unsigned x = 3; x <= border_len - 4; x++) {
+            float bottom_weight = y / (float) (border_len - 1);
+            float top_weight = 1 - bottom_weight;
+            float right_weight = x / (float) (border_len - 1);;
+            float left_weight = 1 - right_weight;
+
+            sq_point top_left_source =
+                {top_border[x].x + left_border[y].x - left_border[0].x,
+                top_border[x].y + left_border[y].y - left_border[0].y};
+
+            sq_point bottom_right_source =
+                {bottom_border[x].x + right_border[y].x
+                - right_border[border_len - 1].x,
+                bottom_border[x].y + right_border[y].y
+                - right_border[border_len - 1].y};
+
+            const unsigned char *data = img->data;
+            unsigned sample_x = top_left_source.x;
+            unsigned sample_y = top_left_source.y;
+            unsigned char top_left_color =
+                data[sample_y * img->width + sample_x];
+            sample_x = bottom_right_source.x;
+            sample_y = bottom_right_source.y;
+            unsigned char bottom_right_color =
+                data[sample_y * img->width + sample_x];
+
+            unsigned char mixed_color =
+                ((top_weight + left_weight) * top_left_color
+                + (bottom_weight + right_weight) * bottom_right_color) / 2;
+
+            if (is_black_color(mixed_color))
+                buf[idx / 8] |= 1 << 7 - idx % 8;
+            idx++;
+        }
+    }
+    error = sq_extract_text(iscn, buf, byte_len);
+    free(buf);
+
+free_borders:
+    free(top_border);
+    free(left_border);
+    free(right_border);
+    free(bottom_border);
+    return error? 1: 0;
+}
Index: zbar-0.10+doc/zbar/sqcode.h
===================================================================
--- /dev/null
+++ zbar-0.10+doc/zbar/sqcode.h
@@ -0,0 +1,23 @@
+/*Copyright (C) 2018 Javier Serrano Polo <javier@jasp.net>
+  You can redistribute this library and/or modify it under the terms of the
+   GNU Lesser General Public License as published by the Free Software
+   Foundation; either version 2.1 of the License, or (at your option) any later
+   version.*/
+#ifndef _SQCODE_H_
+#define _SQCODE_H_
+
+#include <zbar.h>
+
+typedef struct sq_reader sq_reader;
+
+sq_reader *_zbar_sq_create(void);
+void _zbar_sq_destroy(sq_reader *reader);
+void _zbar_sq_reset(sq_reader *reader);
+
+int _zbar_sq_new_config(sq_reader *reader,
+                        unsigned config);
+int _zbar_sq_decode(sq_reader *reader,
+                    zbar_image_scanner_t *iscn,
+                    zbar_image_t *img);
+
+#endif
Index: zbar-0.10+doc/zbar/symbol.c
===================================================================
--- zbar-0.10+doc.orig/zbar/symbol.c
+++ zbar-0.10+doc/zbar/symbol.c
@@ -43,6 +43,7 @@ const char *zbar_get_symbol_name (zbar_s
     case ZBAR_CODE128: return("CODE-128");
     case ZBAR_PDF417: return("PDF417");
     case ZBAR_QRCODE: return("QR-Code");
+    case ZBAR_SQCODE: return("SQ-Code");
     default: return("UNKNOWN");
     }
 }
Index: zbar-0.10+doc/zbar/window.c
===================================================================
--- zbar-0.10+doc.orig/zbar/window.c
+++ zbar-0.10+doc/zbar/window.c
@@ -91,7 +91,7 @@ static inline int window_draw_overlay (z
         const zbar_symbol_t *sym = w->image->syms->head;
         for(; sym; sym = sym->next) {
             uint32_t color = ((sym->cache_count < 0) ? 4 : 2);
-            if(sym->type == ZBAR_QRCODE)
+            if(sym->type == ZBAR_QRCODE || sym->type == ZBAR_SQCODE)
                 window_outline_symbol(w, color, sym);
             else {
                 /* FIXME linear bbox broken */
